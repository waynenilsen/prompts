# Email

React Email templates with stage-based transport: Mailhog for local development, SendGrid for production.

---

## Philosophy

> "Email is infrastructure, not a feature."

Email should work identically in development and production. The only difference is where messages go:
- **Local:** Mailhog captures all emails for inspection
- **Production:** SendGrid delivers to real recipients

No external accounts needed for local development. No email "testing" services. Just Docker.

---

## Architecture

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  React Email    │────▶│  Email Service  │────▶│  Transport      │
│  (Templates)    │     │  (src/lib/email)│     │  (STAGE-based)  │
└─────────────────┘     └─────────────────┘     └─────────────────┘
                                                        │
                              ┌─────────────────────────┼─────────────────────────┐
                              │                         │                         │
                              ▼                         ▼                         ▼
                        ┌───────────┐           ┌───────────┐           ┌───────────┐
                        │  Mailhog  │           │  Console  │           │  SendGrid │
                        │  (local)  │           │  (test)   │           │  (prod)   │
                        └───────────┘           └───────────┘           └───────────┘
```

### The STAGE Environment Variable

| STAGE | Transport | Use Case |
|-------|-----------|----------|
| `local` (default) | Mailhog SMTP | Local development |
| `test` | Console (logged) | Unit/integration tests |
| `production` | SendGrid API | Production deployment |

---

## Setup

### Dependencies

```bash
# React Email for templates
bun add react-email @react-email/components

# Transport libraries
bun add nodemailer @sendgrid/mail

# Types
bun add -d @types/nodemailer
```

### Docker Compose

Mailhog runs via Docker Compose with project-specific ports to avoid collisions:

```yaml
# docker-compose.yml
services:
  mailhog:
    image: mailhog/mailhog
    ports:
      - "${MAILHOG_SMTP_PORT:-52341}:1025"   # SMTP
      - "${MAILHOG_WEB_PORT:-52342}:8025"    # Web UI
```

Ports are randomly generated (50000-60000) during project bootstrap and stored in `.env`:

```bash
# .env (generated by bootstrap)
STAGE=local
MAILHOG_SMTP_PORT=52341
MAILHOG_WEB_PORT=52342
PORT=53210
```

### Start Mailhog

```bash
docker compose up -d
```

Access the web UI at `http://localhost:${MAILHOG_WEB_PORT}` to view captured emails.

---

## Email Service

The email service abstracts transport selection based on `STAGE`:

```typescript
// src/lib/email.ts
import { render } from '@react-email/components';
import nodemailer from 'nodemailer';
import sgMail from '@sendgrid/mail';

const STAGE = process.env.STAGE || 'local';

// Configure SendGrid for production
if (STAGE === 'production' && process.env.SENDGRID_API_KEY) {
  sgMail.setApiKey(process.env.SENDGRID_API_KEY);
}

// Mailhog transporter for local development
const mailhogTransport = nodemailer.createTransport({
  host: 'localhost',
  port: Number(process.env.MAILHOG_SMTP_PORT) || 1025,
  secure: false,
});

interface SendEmailOptions {
  to: string | string[];
  subject: string;
  template: React.ReactElement;
  from?: string;
}

interface SendEmailResult {
  success: boolean;
  messageId?: string;
  error?: Error;
}

export async function sendEmail({
  to,
  subject,
  template,
  from,
}: SendEmailOptions): Promise<SendEmailResult> {
  const html = await render(template);
  const defaultFrom = process.env.EMAIL_FROM || 'noreply@example.com';
  const sender = from || defaultFrom;

  try {
    if (STAGE === 'production') {
      const [response] = await sgMail.send({
        to,
        from: sender,
        subject,
        html,
      });
      return { success: true, messageId: response.headers['x-message-id'] };
    }

    if (STAGE === 'test') {
      // Log to console for test visibility
      console.log(`[EMAIL] To: ${to}, Subject: ${subject}`);
      return { success: true, messageId: 'test-message-id' };
    }

    // Local: send to Mailhog
    const info = await mailhogTransport.sendMail({
      to,
      from: sender,
      subject,
      html,
    });
    return { success: true, messageId: info.messageId };
  } catch (error) {
    console.error('[EMAIL ERROR]', error);
    return {
      success: false,
      error: error instanceof Error ? error : new Error('Unknown error'),
    };
  }
}
```

---

## Templates

Email templates are React components in `src/emails/`:

```
src/
├── emails/
│   ├── welcome.tsx
│   ├── password-reset.tsx
│   ├── order-confirmation.tsx
│   └── components/           # Shared email components
│       ├── header.tsx
│       ├── footer.tsx
│       └── button.tsx
```

### Example Template

```typescript
// src/emails/welcome.tsx
import {
  Html,
  Head,
  Body,
  Container,
  Section,
  Text,
  Button,
  Img,
  Hr,
} from '@react-email/components';

interface WelcomeEmailProps {
  name: string;
  loginUrl: string;
}

export function WelcomeEmail({ name, loginUrl }: WelcomeEmailProps) {
  return (
    <Html>
      <Head />
      <Body style={main}>
        <Container style={container}>
          <Section>
            <Text style={heading}>Welcome, {name}!</Text>
            <Text style={paragraph}>
              Thanks for signing up. We're excited to have you on board.
            </Text>
            <Button style={button} href={loginUrl}>
              Get Started
            </Button>
            <Hr style={hr} />
            <Text style={footer}>
              If you didn't create this account, you can ignore this email.
            </Text>
          </Section>
        </Container>
      </Body>
    </Html>
  );
}

// Styles
const main = {
  backgroundColor: '#f6f9fc',
  fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
};

const container = {
  backgroundColor: '#ffffff',
  margin: '0 auto',
  padding: '40px 20px',
  maxWidth: '560px',
};

const heading = {
  fontSize: '24px',
  fontWeight: 'bold',
  color: '#1a1a1a',
};

const paragraph = {
  fontSize: '16px',
  lineHeight: '26px',
  color: '#4a4a4a',
};

const button = {
  backgroundColor: '#000000',
  borderRadius: '4px',
  color: '#ffffff',
  fontSize: '16px',
  fontWeight: 'bold',
  textDecoration: 'none',
  padding: '12px 24px',
  display: 'inline-block',
};

const hr = {
  borderColor: '#e6e6e6',
  margin: '26px 0',
};

const footer = {
  fontSize: '14px',
  color: '#8c8c8c',
};
```

### Links and URLs

**Critical: All links in emails must use absolute URLs (full base URL).**

Emails are viewed in external email clients (Gmail, Outlook, Apple Mail, etc.), not within your application. Relative paths like `/login` or `./reset` will not work—they'll resolve relative to the email client, not your domain.

Always use the full base URL:

```typescript
// ❌ Wrong - relative path
<Button href="/login">Login</Button>

// ✅ Right - absolute URL
const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://app.example.com';
<Button href={`${baseUrl}/login`}>Login</Button>
```

When sending emails, construct URLs using your application's base URL:

```typescript
// src/server/routers/auth.ts
const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://app.example.com';

await sendEmail({
  to: user.email,
  subject: 'Welcome!',
  template: (
    <WelcomeEmail 
      name={user.name} 
      loginUrl={`${baseUrl}/login`}
      resetUrl={`${baseUrl}/reset?token=${token}`}
    />
  ),
});
```

Set `NEXT_PUBLIC_BASE_URL` in your environment variables (the `NEXT_PUBLIC_` prefix makes it available to both server and client):
- **Local:** `NEXT_PUBLIC_BASE_URL=http://localhost:3000`
- **Production:** `NEXT_PUBLIC_BASE_URL=https://yourdomain.com`

### Sending the Email

**Use tRPC, not Server Actions.** See [tRPC Guide](./trpc.md) for complete patterns.

```typescript
// src/server/routers/auth.ts
import { z } from 'zod';
import { router, publicProcedure } from '@/server/trpc';
import { sendEmail } from '@/lib/email';
import { WelcomeEmail } from '@/emails/welcome';

const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://app.example.com';

export const authRouter = router({
  register: publicProcedure
    .input(
      z.object({
        email: z.string().email(),
        name: z.string().optional(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      const user = await ctx.prisma.user.create({
        data: input,
      });

      await sendEmail({
        to: user.email,
        subject: 'Welcome to Our App!',
        template: <WelcomeEmail name={user.name} loginUrl={`${baseUrl}/login`} />,
      });

      return user;
    }),
});
```

---

## Testing

### Unit Tests

Mock the email service in tests:

```typescript
// src/lib/email.test.ts
import { describe, test, expect, mock, beforeEach } from 'bun:test';
import { sendEmail } from './email';
import { WelcomeEmail } from '@/emails/welcome';

// Set test stage
process.env.STAGE = 'test';

describe('sendEmail', () => {
  beforeEach(() => {
    // Clear console mock between tests
  });

  test('sends email successfully in test mode', async () => {
    const result = await sendEmail({
      to: 'test@example.com',
      subject: 'Test Subject',
      template: <WelcomeEmail name="Test User" loginUrl="https://example.com" />,
    });

    expect(result.success).toBe(true);
    expect(result.messageId).toBe('test-message-id');
  });

  test('handles array of recipients', async () => {
    const result = await sendEmail({
      to: ['user1@example.com', 'user2@example.com'],
      subject: 'Group Email',
      template: <WelcomeEmail name="Users" loginUrl="https://example.com" />,
    });

    expect(result.success).toBe(true);
  });
});
```

### Integration Tests (with Mailhog)

For integration tests that verify actual email delivery:

```typescript
// src/lib/email.integration.test.ts
import { describe, test, expect, beforeAll, afterAll } from 'bun:test';
import { sendEmail } from './email';
import { WelcomeEmail } from '@/emails/welcome';

// These tests require Mailhog running
describe('email integration', () => {
  beforeAll(() => {
    process.env.STAGE = 'local';
  });

  test('delivers email to Mailhog', async () => {
    const result = await sendEmail({
      to: 'integration@test.com',
      subject: 'Integration Test',
      template: <WelcomeEmail name="Integration" loginUrl="https://test.com" />,
    });

    expect(result.success).toBe(true);
    expect(result.messageId).toBeDefined();

    // Optionally verify via Mailhog API
    const mailhogPort = process.env.MAILHOG_WEB_PORT || 8025;
    const response = await fetch(`http://localhost:${mailhogPort}/api/v2/messages`);
    const data = await response.json();

    expect(data.items.some((m: any) => m.Content.Headers.Subject[0] === 'Integration Test')).toBe(true);
  });
});
```

### Preview Mode

Use React Email's preview server during development:

```bash
# Add to package.json scripts
"email:dev": "email dev --dir src/emails --port 3001"
```

```bash
bun run email:dev
```

Open `http://localhost:3001` to preview and iterate on templates.

---

## Production Configuration

### Environment Variables

For production (Sprite), set these environment variables:

```bash
STAGE=production
NEXT_PUBLIC_BASE_URL=https://yourdomain.com
SENDGRID_API_KEY=SG.xxx...
EMAIL_FROM=noreply@yourdomain.com
```

**Important:** `NEXT_PUBLIC_BASE_URL` is required for all email links to work correctly. Without it, relative paths in emails will break when viewed in external email clients. The `NEXT_PUBLIC_` prefix makes it available to both server-side (for email generation) and client-side code.

### SendGrid Setup

1. Create a SendGrid account
2. Verify your sending domain
3. Generate an API key with "Mail Send" permission
4. Set `SENDGRID_API_KEY` in production environment

### Sender Verification

SendGrid requires sender verification. Options:
- **Domain authentication** (recommended): Verify your domain via DNS records
- **Single sender verification**: Verify individual email addresses

---

## Patterns

### Shared Components

Extract common email elements:

```typescript
// src/emails/components/email-button.tsx
import { Button } from '@react-email/components';

interface EmailButtonProps {
  href: string;
  children: React.ReactNode;
}

export function EmailButton({ href, children }: EmailButtonProps) {
  return (
    <Button
      href={href}
      style={{
        backgroundColor: '#000000',
        borderRadius: '4px',
        color: '#ffffff',
        fontSize: '16px',
        fontWeight: 'bold',
        padding: '12px 24px',
      }}
    >
      {children}
    </Button>
  );
}
```

### Email Queue (Optional)

For high-volume applications, queue emails instead of sending synchronously:

```typescript
// src/lib/email-queue.ts
import { prisma } from '@/lib/prisma';
import { sendEmail } from './email';

interface QueuedEmail {
  to: string;
  subject: string;
  templateName: string;
  templateData: Record<string, unknown>;
}

export async function queueEmail(email: QueuedEmail) {
  return prisma.emailQueue.create({
    data: {
      to: email.to,
      subject: email.subject,
      templateName: email.templateName,
      templateData: JSON.stringify(email.templateData),
      status: 'pending',
    },
  });
}

// Process queue (run via cron or background worker)
export async function processEmailQueue() {
  const pending = await prisma.emailQueue.findMany({
    where: { status: 'pending' },
    take: 10,
  });

  for (const email of pending) {
    // Load and render template
    // Send email
    // Update status
  }
}
```

---

## Checklist

Before shipping email functionality:

- [ ] React Email templates created
- [ ] Email service abstraction working
- [ ] Mailhog running locally (`docker compose up -d`)
- [ ] Test emails visible in Mailhog web UI
- [ ] Unit tests pass with `STAGE=test`
- [ ] All email links use absolute URLs (via `NEXT_PUBLIC_BASE_URL`)
- [ ] `NEXT_PUBLIC_BASE_URL` configured for production
- [ ] `EMAIL_FROM` configured for production
- [ ] SendGrid API key set for production
- [ ] Sender domain verified in SendGrid

---

## Quick Reference

```bash
# Start Mailhog
docker compose up -d

# View Mailhog web UI
open http://localhost:${MAILHOG_WEB_PORT}

# Preview email templates
bun run email:dev

# Run email tests
STAGE=test bun test src/lib/email.test.ts

# Send test email (local)
STAGE=local bun run scripts/send-test-email.ts
```

```typescript
// Send an email
import { sendEmail } from '@/lib/email';
import { WelcomeEmail } from '@/emails/welcome';

const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://app.example.com';

await sendEmail({
  to: 'user@example.com',
  subject: 'Welcome!',
  template: <WelcomeEmail name="User" loginUrl={`${baseUrl}/login`} />,
});
```

---

## Related

- [Project Setup](./setup.md) - Full stack setup including email
- [Unit Testing](./unit-testing.md) - Testing patterns for email
- [Engineering Requirements Document](./erd.md) - Email in technical constraints
